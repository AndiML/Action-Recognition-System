"""Represents a module that contains the application."""

import os
import shutil
import sys
import random
import logging
import argparse
from typing import Literal

import numpy

from action_recognition.commands import get_command_descriptors, get_command

__version__ = '0.1.0'
"""Contains the version number of the application."""

class SectioningFormatter(logging.Formatter):
    """Represents a logger formatting, which allows the user to separate log messages into sections by adding horizontal rulers."""

    def format(self, record: logging.LogRecord) -> str:
        """Formats the specified log record as text. If the caller specified that a section should be started or ended, then a horizontal ruler will
        be added before or after the log message respectively.

        Args:
            record (logging.LogRecord): The log record that is to be formatted as text.

        Returns:
            str: Returns the formatted log record.
        """

        # Gets the width of the terminal, which is the width in characters that the horizontal ruler should have
        terminal_width, _ = shutil.get_terminal_size()

        # Uses the base class implementation of the format method to format the record
        formatted_log_record = super().format(record)

        # If the caller requested that a new section should be begun or the current section should be ended, then horizontal rulers (consisting of as
        # many dashes as the terminal is wide) are added before and/or after the formatted log record
        if hasattr(record, 'start_section') and record.start_section:
            formatted_log_record = f'{"-" * terminal_width}{os.linesep}{formatted_log_record}'
        if hasattr(record, 'end_section') and record.end_section:
            formatted_log_record = f'{formatted_log_record}{os.linesep}{"-" * terminal_width}'

        # Returns the formatted log record
        return formatted_log_record


class Application:
    """Represents the command line application."""

    def run(self) -> None:
        """Runs the application. This is the actual entry-point to the application."""

        # Parses the command line arguments of the application
        arguments = self.parse_command_line_arguments()

        # Configure logging to suppress specific debug messages from matplotlib and PIL
        self.configure_library_logging()

        logger = logging.getLogger(__name__ + '.' + self.__class__.__name__)
        # Configures the root logger of the and creates a logger for the application
        if "output_path" in arguments:
            self.configure_logging(
                arguments.verbosity,
                os.path.join(arguments.output_path, 'experiment.log') if arguments.output_path is not None else None
            )

        # Makes the experiment reproducible by fixing the seed of the random number generator and putting the GPU in a deterministic mode, if the user
        # did not specify a random seed, a seed is randomly generated and logged, so that the experiment can be repeated later on (the seed is
        # generated by using the Python built-in random number generator, the random seed must be a 32-bit unsigned integer, i.e., between 0 and
        # 2^23-1, because the NumPy requires seeds to be 32-bit unsigned integers)
        if arguments.random_seed is None:
            arguments.random_seed = random.randint(0, 2**32 - 1)
            logger.info('No random seed was specified, using %d.', arguments.random_seed)
        import torch  # pylint: disable=import-outside-toplevel
        os.environ["CUBLAS_WORKSPACE_CONFIG"] = ":16:8"
        random.seed(arguments.random_seed)
        torch.manual_seed(arguments.random_seed)
        numpy.random.seed(arguments.random_seed)
        torch.backends.cudnn.deterministic = True
        torch.backends.cudnn.benchmark = False
        torch.use_deterministic_algorithms(mode=True)  # type: ignore

        # Finds the command that is to be run
        if arguments.command is None:
            logger.error('No command was specified.')
            sys.exit(1)
        try:
            command_class = get_command(arguments.command)
            command = command_class()
            command.run(arguments)
        except Exception:  # pylint: disable=broad-except
            logger.exception('An error occurred in the command "%s".', arguments.command)

    def configure_logging(
        self,
        logging_level: Literal['all', 'debug', 'info', 'warning', 'error', 'critical'],
        log_file_path: str | None
    ) -> None:
        """Configures the root logger of the application, creates a logger for this application, and sets up its logging handlers.

        Args:
            logging_level (Literal['all', 'debug', 'info', 'warning', 'error', 'critical']): The logging level for the root logger.
            log_file_path (str | None): The path to the file into which the logs are to be written. If None is specified, then the logger only outputs
                to the console.
        """

        # Creates a new parent logger for the application
        root_logger = logging.getLogger()

        # Sets the logging level for the logger
        logging_level_map = {
            'all': logging.NOTSET,
            'debug': logging.DEBUG,
            'info': logging.INFO,
            'warning': logging.WARNING,
            'error': logging.ERROR,
            'critical': logging.CRITICAL
        }
        root_logger.setLevel(logging_level_map[logging_level])
        # Adds a console logging handler to the application logger and an optional file handler
        sectioning_formatter = SectioningFormatter('%(asctime)s - %(name).45s - %(levelname)s - %(message)s')
        console_logging_handler = logging.StreamHandler(sys.stdout)
        console_logging_handler.setLevel(logging_level_map[logging_level])
        console_logging_handler.setFormatter(sectioning_formatter)
        root_logger.addHandler(console_logging_handler)
        if log_file_path is not None:
            file_logging_handler = logging.FileHandler(log_file_path)
            file_logging_handler.setLevel(logging_level_map[logging_level])
            file_logging_handler.setFormatter(sectioning_formatter)
            root_logger.addHandler(file_logging_handler)

        # Returns the application logger
        # return application_logger

    def configure_library_logging(self) -> None:
        """Suppresses specific debug messages from matplotlib and PIL."""
        
        logging.getLogger('PIL').setLevel(logging.WARNING)
        logging.getLogger('matplotlib.font_manager').setLevel(logging.ERROR)
        logging.getLogger('matplotlib').setLevel(logging.WARNING)

    def parse_command_line_arguments(self) -> argparse.Namespace:
        """Parses the command line arguments.

        Returns:
            argparse.Namespace: Returns an object, which contains the command line arguments.
        """

        # Creates a command line argument parser for the application
        argument_parser = argparse.ArgumentParser(
            prog='action_recognition',
            description='A command line tool for experiments for Action Recognition.',
            add_help=False
        )

        # Adds the command line argument that displays the help message
        argument_parser.add_argument(
            '-h',
            '--help',
            action='help',
            help='Shows this help message and exits.'
        )

        # Adds the command line argument for the version of the application
        argument_parser.add_argument(
            '-v',
            '--version',
            action='version',
            version=f'Action Recognition  {__version__}',
            help='Displays the version string of the application and exits.'
        )

        # Adds the command line argument, which enables the reproducibility of the experiments by fixing the seed of the random number generator
        argument_parser.add_argument(
            '-r',
            '--random-seed',
            dest='random_seed',
            type=int,
            help='''
                Sets the seed for the random number generator. Specifying a random seed ensures that an experiment is reproducible. If not specified,
                a random seed will randomly generated and logged, so that the experiment can still be reproduced later on.
            '''
        )

        # Adds the command line argument for the verbosity of the logging
        argument_parser.add_argument(
            '-V',
            '--verbosity',
            dest='verbosity',
            type=str,
            choices=['all', 'debug', 'info', 'warning', 'error', 'critical'],
            default='debug',
            help='Sets the verbosity level of the logging. Defaults to "debug".'
        )

        # Adds the command line argument for the path to the file into which the logs are to be written
        argument_parser.add_argument(
            '-l',
            '--log-file-path',
            dest='log_file_path',
            type=str,
            help='The path to the file into which the logs are to be written. If not specified, then the logs are just output to the standard output.'
        )

        # Adds the commands
        command_descriptors = get_command_descriptors()
        sub_parsers = argument_parser.add_subparsers(dest='command')
        for command_descriptor in command_descriptors:
            command_parser = sub_parsers.add_parser(command_descriptor.get_name(), help=command_descriptor.get_description(), add_help=False)
            command_parser.add_argument(
                '-h',
                '--help',
                action='help',
                help='Shows this help message and exits.'
            )
            command_descriptor.add_arguments(command_parser)

        # Parses the arguments
        return argument_parser.parse_args()
